diff --git a/yatebts/sar/sar_lib.js b/yatebts/sar/sar_lib.js
index 2e1ff92..fbbdd50 100644
--- a/yatebts/sar/sar_lib.js
+++ b/yatebts/sar/sar_lib.js
@@ -23,12 +23,18 @@
   */
 
 #require "javascript.js"
+
+#require "utils.js"
 #require "sar_config.js"
+
 #require "subscribers.js"
 #require "sms.js"
-#require "utils.js"
+
+/* ############### Engine State ############### */
 
 Engine.debugName("searchandrescue");
+var radioStopped = false;
+var radioStoppedReason = null;
 
 /* ############### SAR SDK ############### */
 
@@ -62,7 +68,10 @@ function initializeSAR() {
    Message.install(onHandsetUnregister, "user.unregister", 80);
    Message.install(onPhyinfo, "phyinfo", 80);
    Message.install(onSMS, "msg.execute", 80, "callto", droneRootImsi); // receives SMSes that are routed to the drone IMSI
+   Message.install(onEngineStatus, "engine.status", 75);
+   Message.install(onYBTSStatus, "ybts.status", 75);
    // Message.install(onRoute, "call.route", 80); TODO: route sms messages
+
    Engine.setInterval(onIntervalMaster, intervals.master);
 
    // setup periodic actions
@@ -70,7 +79,7 @@ function initializeSAR() {
    installPeriodicAction(heartbeat, intervals.heartbeat, 'heartbeat');
    installPeriodicAction(expireSubscribers, intervals.subscriberExpire, 'expireSubscribers');
    installPeriodicAction(sendSilentSMSs, intervals.phyinfoPolling, 'pollPhyinfo');
-   installPeriodicAction(sendNextSMS, intervals.sensSMS, 'sendSMS');
+   installPeriodicAction(sendNextSMS, intervals.sendSMS, 'sendSMS');
 
    // Ready!
    Engine.debug(Engine.DebugInfo, "Search and Rescue Cell Site is UP! Let's go save some lives.");
@@ -80,7 +89,7 @@ var periodicActions = [];
 
 function installPeriodicAction(action, delay, name) {
    if (delay <= 0) {
-      Engine.alarm(4, "A Periodic Action must have a positive delay");
+      Engine.alarm(4, "A Periodic Action must have a positive delay (action=" + name + ")");
       return;
    } else if (delay < 1000) {
       Engine.debug(Engine.DebugInfo, "WARNING: periodic actions are untested with delays less than 1000");
@@ -102,6 +111,35 @@ function installPeriodicAction(action, delay, name) {
 
 var onInterval, onPhoneDetected, onPhoneLost, onSendSMS, onSMSReceived, onSignalReceived;
 
+function onEngineStatus(msg) {
+   log("engine.status detected. Message contents:");
+   for (var key in msg) {
+      log(" - " + key + ": " + msg[key]);
+   }
+}
+
+function onYBTSStatus(msg) {
+   var data = {'type': msg.type};
+
+   switch (msg.type) {
+      case "stopnotification":
+         data.restarting = msg.restarting;
+         data.reason = msg.reason;
+         if (!msg.restarting) {
+            radioStopped = true;
+            radioStoppedReason = msg.reason;
+         }
+         break;
+      case "timeout":
+         data['for'] = msg['for'];
+         break;
+      default:
+         break;
+   }
+
+   writeToOCP(data, "ybts");
+}
+
 function onAuth(msg) {
 
 	// Auth always succeeds -- this is the weakness in GSM that makes this strategy viable!
@@ -206,7 +244,16 @@ function heartbeat() {
       return {'imsi': sub.imsi, 'tmsi': sub.tmsi, 'msisdn': sub.msisdn};
    });
 
+   var radio = {
+      'stopped': radioStopped,
+      'stoppedReason': radioStoppedReason
+   };
+
+   var started = Engine.started();
    var info = {
+      'ybtsTimersState': ybtsTimersState,
+      'engineStarted': started,
+      'radio': radio,
       'subscribers': subs,
       'pendingSMSs': pendingSMSs.length
    };
@@ -228,3 +275,4 @@ function onIntervalMaster() {
       }
    }
 }
+
diff --git a/yatebts/ybts.cpp b/yatebts/ybts.cpp
index 4088c86..a92ac9e 100644
--- a/yatebts/ybts.cpp
+++ b/yatebts/ybts.cpp
@@ -263,6 +263,23 @@ static void send_phyinfo_message(const char *imsi, const char *tmsi,
    m->destruct();
 }
 
+static Message *make_engine_status_message(const char *type, const bool dispatch=false) {
+   Message *m = new Message("ybts.status");
+   m->addParam("type", type);
+
+   if (dispatch) {
+      Engine::dispatch(m);
+      m->destruct();
+      return nullptr;
+   }
+   return m;
+}
+
+static void dispatch_engine_status_message(Message *m) {
+   Engine::dispatch(m);
+   m->destruct();
+}
+
 class YBTSConnIdHolder
 {
 public:
@@ -4246,8 +4263,13 @@ int YBTSSignalling::checkTimers(const Time& time)
     if (m_state == Closing || m_state == Idle)
 	return Ok;
     if (m_timeout && m_timeout <= time) {
-	Alarm(this,"system",DebugWarn,"Timeout while waiting for %s [%p]",
-	    (m_state != WaitHandshake  ? "heartbeat" : "handshake"),this);
+	const char *type = m_state != WaitHandshake ? "heartbeat" : "handshake";
+	Alarm(this,"system",DebugWarn,"Timeout while waiting for %s [%p]", type ,this);
+
+        Message *m = make_engine_status_message("timeout");
+        m->addParam("for", type);
+        dispatch_engine_status_message(m);
+
 	changeState(Closing,true);
 	return Error;
     }
@@ -5181,10 +5203,17 @@ int YBTSSignalling::handleStopNotification(YBTSMessage& msg)
 	    appendChildText(s,msg.xml(),YSTRING("reason"));
 	appendChildText(s,msg.xml(),YSTRING("operation"));
     }
+
     if (restart)
 	Debug(this,DebugNote,"Peer stop notification '%s'%s [%p]",notif.c_str(),s.safe(),this);
     else
 	Alarm(this,"system",DebugWarn,"Peer fatal stop notification '%s'%s [%p]",notif.c_str(),s.safe(),this);
+
+    Message *m = make_engine_status_message("stopnotification");
+    m->addParam("restarting", restart ? "true" : "false");
+    m->addParam("reason", notif.c_str());
+    dispatch_engine_status_message(m);
+
     return restart ? Error : FatalError;
 }
 
