diff --git a/yate/Makefile.in b/yate/Makefile.in
index b26bc27..296de8e 100644
--- a/yate/Makefile.in
+++ b/yate/Makefile.in
@@ -225,6 +225,7 @@ install-noconf: all
 	$(MAKE) -C ./modules install
 	$(MAKE) -C ./clients install
 	$(MAKE) -C ./share install
+	$(MAKE) -C ./tools install
 	@$(LDCONFIG)
 	@mkdir -p "$(DESTDIR)$(mandir)/man8/" && \
 	for i in $(MAN8) ; do \
diff --git a/yate/configure.ac b/yate/configure.ac
index 20fcb09..15e2c2d 100644
--- a/yate/configure.ac
+++ b/yate/configure.ac
@@ -1792,7 +1792,8 @@ AC_CONFIG_FILES([packing/rpm/yate.spec
                  share/sounds/Makefile
                  share/help/Makefile
                  share/data/Makefile
-                 conf.d/Makefile])
+                 conf.d/Makefile
+                 tools/Makefile])
 AC_CONFIG_FILES([yate-config],[chmod +x yate-config])
 AC_CONFIG_FILES([run],[chmod +x run])
 CONFIGURE_FILES=`echo "$ac_config_files config.status config.log" | sed 's,packing/[[^ ]]* *,,g'`
diff --git a/yate/modules/Makefile.in b/yate/modules/Makefile.in
index 0b68a1d..eb0c952 100644
--- a/yate/modules/Makefile.in
+++ b/yate/modules/Makefile.in
@@ -59,22 +59,18 @@ JUSTSIG := server/ysigchan.yate server/analog.yate \
 
 SUBDIRS :=
 MKDEPS  := ../config.status
-PROGS := cdrbuild.yate cdrcombine.yate cdrfile.yate regexroute.yate \
-	tonegen.yate tonedetect.yate wavefile.yate \
-	extmodule.yate conference.yate moh.yate pbx.yate \
-	dumbchan.yate callfork.yate mux.yate \
+PROGS := regexroute.yate \
+	jabber/jabberserver.yate jabber/jbfeatures.yate \
+	tonegen.yate tonedetect.yate \
+	extmodule.yate moh.yate pbx.yate \
+	callfork.yate mux.yate \
 	yrtpchan.yate ystunchan.yate \
-	ysipchan.yate \
-	yiaxchan.yate \
-	yjinglechan.yate jabber/jabberserver.yate jabber/jbfeatures.yate \
 	ysockschan.yate filetransfer.yate fileinfo.yate \
-	gvoice.yate \
 	javascript.yate \
 	server/pbxassist.yate server/dbpbx.yate server/lateroute.yate \
 	server/park.yate server/queues.yate server/queuesnotify.yate \
-	server/regfile.yate server/accfile.yate server/register.yate \
+	server/regfile.yate server/register.yate \
 	server/callcounters.yate server/cpuload.yate server/ccongestion.yate \
-	server/dbwave.yate \
 	server/yradius.yate \
 	server/ysnmpagent.yate \
 	server/monitoring.yate \
@@ -89,21 +85,32 @@ PROGS := cdrbuild.yate cdrcombine.yate cdrfile.yate regexroute.yate \
 	server/analogdetect.yate \
 	server/cache.yate \
 	server/eventlogs.yate \
-	client/jabberclient.yate \
 	callgen.yate analyzer.yate rmanager.yate msgsniff.yate \
-	radio/dummyradio.yate
+	radio/dummyradio.yate \
+   searchandrescue.yate
+
+# Removed from the default yate configuration
+OLD_PROGS := cdrbuild.yate cdrcombine.yate cdrfile.yate \
+	client/jabberclient.yate \
+	server/accfile.yate \
+	server/dbwave.yate \
+	dumbchan.yate conference.yate \
+	gvoice.yate \
+	wavefile.yate \
+	ysipchan.yate yjinglechan.yate \
+	yiaxchan.yate 
 
 LIBS :=
 DIRS := client server jabber qt4 sip sig radio
 PROGS := $(PROGS) server/overlapdial.yate lazyrec.yate
 
-ifneq ($(HAVE_PGSQL),no)
-PROGS := $(PROGS) server/pgsqldb.yate
-endif
+# ifneq ($(HAVE_PGSQL),no)
+# PROGS := $(PROGS) server/pgsqldb.yate
+# endif
 
-ifneq ($(HAVE_MYSQL),no)
-PROGS := $(PROGS) server/mysqldb.yate
-endif
+# ifneq ($(HAVE_MYSQL),no)
+# PROGS := $(PROGS) server/mysqldb.yate
+# endif
 
 ifneq ($(HAVE_SQLITE),no)
 PROGS := $(PROGS) server/sqlitedb.yate
@@ -277,6 +284,9 @@ qt4/%.o: @srcdir@/qt4/%.cpp $(MKDEPS) $(INCFILES)
 %.o: @srcdir@/%.cpp $(MKDEPS) $(INCFILES)
 	$(COMPILE) -c $<
 
+mqcommon.o: mqcommon.cpp $(MKDEPS) $(INCFILES)
+	$(COMPILE) -c $< -lrt
+
 do-all do-strip do-clean do-install do-uninstall:
 	$(if $(SUBDIRS),\
 	@target=`echo $@ | $(SED) -e 's/^do-//'`; \
@@ -315,6 +325,9 @@ sip/%.yate: @srcdir@/sip/%.cpp $(MKDEPS) $(INCFILES)
 %.yate: @srcdir@/%.cpp $(MKDEPS) $(INCFILES)
 	$(MODCOMP) -o $@ $(LOCALFLAGS) $(EXTERNFLAGS) $< $(LOCALLIBS) $(YATELIBS) $(EXTERNLIBS)
 
+searchandrescue.yate: searchandrescue.cpp mqcommon.o $(MKDEPS) $(INCFILES)
+	$(MODCOMP) mqcommon.o -o $@ $(LOCALFLAGS) $(EXTERNFLAGS) $< $(LOCALLIBS) $(YATELIBS) $(EXTERNLIBS) -lrt
+
 # Take special care of the modules that depend on optional libs
 
 $(JUSTSIG) server/wpcard.yate server/tdmcard.yate server/zapcard.yate: ../libyatesig.so
@@ -418,6 +431,9 @@ javascript.yate: ../libyatescript.so ../libs/ypbx/libyatepbx.a
 javascript.yate: LOCALFLAGS = -I@top_srcdir@/libs/yscript -I@top_srcdir@/libs/ypbx
 javascript.yate: LOCALLIBS = -lyatescript -L../libs/ypbx -lyatepbx
 
+searchandrescue.yate: LOCALFLAGS = -I../libs/yscript
+searchandrescue.yate: LOCALLIBS = -lyatescript
+
 zlibcompress.yate: EXTERNFLAGS = $(ZLIB_INC)
 zlibcompress.yate: EXTERNLIBS = $(ZLIB_LIB)
 
diff --git a/yate/modules/mqcommon.cpp b/yate/modules/mqcommon.cpp
new file mode 100644
index 0000000..c721231
--- /dev/null
+++ b/yate/modules/mqcommon.cpp
@@ -0,0 +1,82 @@
+/** mqcommon.cpp: cpp file for a POSIX message queue to send messages 
+  * to the OCP
+  *    
+  * Cellular Search and Rescue - Cellular Sensor BTS
+  *   Copyright (C) 2017 Microsoft
+  * 
+  * This file is part of cell-sar
+  * 
+  * cell-sar is free software: you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or
+  * (at your option) any later version.
+  * 
+  * cell-sar is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  * 
+  * You should have received a copy of the GNU General Public License
+  * along with cell-sar.  If not, see <http://www.gnu.org/licenses/>.
+  */
+
+
+#include <mqueue.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "mqcommon.h"
+
+bool initialized = false;
+
+mqd_t MQCommon::mq;
+struct mq_attr MQCommon::attr;
+char MQCommon::buffer[MAX_SIZE + 1];
+
+void MQCommon::init(bool write)
+{
+    /* create queue attributes */
+    MQCommon::attr.mq_flags = 0;
+    MQCommon::attr.mq_maxmsg = 10;
+    MQCommon::attr.mq_msgsize = MAX_SIZE;
+    MQCommon::attr.mq_curmsgs = 0;
+
+    if (write)
+    {
+	    /* create the message queue if does not exist and open for writing */
+	    MQCommon::mq = mq_open(QUEUE_NAME, O_CREAT | O_WRONLY | O_NONBLOCK, 0666, &MQCommon::attr);
+	}
+	else
+	{
+		  /* create the message queue for reading */
+		  MQCommon::mq = mq_open(QUEUE_NAME, O_CREAT | O_RDONLY | O_NONBLOCK, 0666, &MQCommon::attr);
+	}
+
+	initialized = true;
+}
+
+void MQCommon::cleanup()
+{
+	mq_close(MQCommon::mq);
+}
+
+void MQCommon::push(const char* buffer)
+{
+	if (!initialized) MQCommon::init(true);
+
+	mq_send(MQCommon::mq, buffer, strlen(buffer), 0);
+}
+
+char* MQCommon::pop()
+{
+	if (!initialized) MQCommon::init(false);
+
+	int bytes_read = mq_receive(mq, MQCommon::buffer, MAX_SIZE, NULL);
+
+    if (bytes_read >= 0)
+    {
+    	return &MQCommon::buffer[0];
+    }
+
+    return NULL;
+}
diff --git a/yate/modules/mqcommon.h b/yate/modules/mqcommon.h
new file mode 100644
index 0000000..3a80276
--- /dev/null
+++ b/yate/modules/mqcommon.h
@@ -0,0 +1,42 @@
+/** mqcommon.h: header file for a POSIX message queue to send messages 
+  * to the OCP
+  *    
+  * Cellular Search and Rescue - Cellular Sensor BTS
+  *   Copyright (C) 2017 Microsoft
+  * 
+  * This file is part of cell-sar
+  * 
+  * cell-sar is free software: you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or
+  * (at your option) any later version.
+  * 
+  * cell-sar is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  * 
+  * You should have received a copy of the GNU General Public License
+  * along with cell-sar.  If not, see <http://www.gnu.org/licenses/>.
+  */
+
+
+#include <mqueue.h>
+
+#define QUEUE_NAME  "/sar"
+#define MAX_SIZE    4096
+
+#define CHECK(x) do { if (!(x)) { fprintf(stderr, "%s:%d: ", __func__, __LINE__); perror(#x); exit(-1); } } while (0)
+
+class MQCommon
+{
+	public:
+  		static void push(const char* buffer);
+  		static char* pop();
+  		static void cleanup();
+	private:
+		static void init(bool write);
+		static mqd_t mq;
+		static struct mq_attr attr;
+		static char buffer[MAX_SIZE + 1];
+};
diff --git a/yate/modules/searchandrescue.cpp b/yate/modules/searchandrescue.cpp
new file mode 100644
index 0000000..437b243
--- /dev/null
+++ b/yate/modules/searchandrescue.cpp
@@ -0,0 +1,241 @@
+/** searchandrescue.cpp: a Yate module that handles communication between 
+  * the SAR javascript automation and the OCP program.
+  *    
+  * Cellular Search and Rescue - Cellular Sensor BTS
+  *   Copyright (C) 2017 Microsoft
+  * Yet Another Telephony Engine - Base Transceiver Station
+  *   Copyright (C) 2013-2014 Null Team Impex SRL
+  *   Copyright (C) 2014 Legba, Inc
+  * 
+  * This file is part of cell-sar/the Yate-BTS Project http://www.yatebts.com
+  * 
+  * cell-sar is free software: you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation, either version 2 of the License, or
+  * (at your option) any later version.
+  * 
+  * cell-sar is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  * 
+  * You should have received a copy of the GNU General Public License
+  * along with cell-sar.  If not, see <http://www.gnu.org/licenses/>.
+  */
+
+#include <ctime>
+#include <fstream>
+#include <iostream>
+#include <limits>
+#include <sstream>
+#include <stdlib.h>
+#include <string>
+
+#include <yatengine.h>
+#include <yatescript.h>
+
+#include "mqcommon.h"
+
+using namespace TelEngine;
+
+class SearchAndRescue : public JsObject {
+   YCLASS(SearchAndRescue, JsObject)
+
+public:
+
+   static const char *OUT_FILE;
+
+   SearchAndRescue(Mutex *mtx);
+
+   virtual ~SearchAndRescue();
+
+   virtual SearchAndRescue *runConstructor(ObjList &stack, const ExpOperation &oper, GenObject *context);
+
+   static void initialize(ScriptContext *context);
+
+protected:
+
+   // bool runNative(ObjList &stack, const ExpOperation &oper, GenObject *context);
+
+   bool runFunction(ObjList &stack, const ExpOperation &oper, GenObject *context);
+
+   void write_to_ocp(ObjList &stack, const ExpOperation &oper, GenObject *context);
+
+   void change_plmn(ObjList &stack, const ExpOperation &oper, GenObject *context);
+
+};
+
+class SearchAndRescueHandler : public MessageHandler {
+
+public:
+
+   SearchAndRescueHandler();
+
+   virtual bool received(Message &msg);
+
+};
+
+class SearchAndRescuePlugin : public Plugin {
+
+public:
+   
+   SearchAndRescuePlugin();
+
+   virtual void initialize();
+
+private:
+
+   SearchAndRescueHandler *m_handler; 
+};
+
+/* ######################### IMPLEMENTATION ######################### */
+
+// --- SearchAndRescue ---
+
+const char *SearchAndRescue::OUT_FILE = "/tmp/sar.log";
+
+SearchAndRescue::SearchAndRescue(Mutex *mtx) : JsObject("SearchAndRescue", mtx, true) {
+   Debug(DebugAll, "SearchAndRescue::SearchAndRescue(%p) [%p]", mtx, this);
+   params().addParam(new ExpFunction("writePhyinfo"));
+   params().addParam(new ExpFunction("writeSms"));
+}
+
+SearchAndRescue::~SearchAndRescue() {
+   Debug(DebugAll, "SearchAndRescue::~SearchAndRescue() [%p]", this);
+}
+
+SearchAndRescue *SearchAndRescue::runConstructor(ObjList &stack, const ExpOperation &oper, GenObject *context) {
+   Debug(DebugAll, "SearchAndRescue::runConstructor '%s'(" FMT64 ") [%p]", oper.name().c_str(), oper.number(), this);
+   const char *val = 0;
+   ObjList args;
+   switch (extractArgs(stack, oper, context, args)) {
+   case 1:
+      val = static_cast<ExpOperation*>(args[0])->c_str();
+      // fall through
+   case 0:
+      return new SearchAndRescue(mutex());
+   default:
+      return 0;
+   }
+}
+
+void SearchAndRescue::initialize(ScriptContext *context) {
+   if (!context) return;
+
+   Mutex *mtx = context->mutex();
+   Lock mylock(mtx);
+   NamedList &params = context->params();
+   if (!params.getParam(YSTRING("SearchAndRescue")))
+      addConstructor(params, "SearchAndRescue", new SearchAndRescue(mtx));
+   else
+      Debug(DebugInfo, "A SearchAndRescue already exists, nothing to do");
+}
+
+bool SearchAndRescue::runFunction(ObjList &stack, const ExpOperation &oper, GenObject *context) {
+   if (oper.name() == YSTRING("writeToOCP"))
+      this->write_to_ocp(stack, oper, context);
+   return true;
+}
+
+void SearchAndRescue::write_to_ocp(ObjList &stack, const ExpOperation &oper, GenObject *context) {
+   ObjList args;
+   int argc = extractArgs(stack, oper, context, args);
+   String tmp;
+   tmp << "SearchAndRescue::write_to_ocp '";
+   std::string message;
+
+   // Evaluate
+   if (argc < 1) {
+      tmp << " ''";
+      ExpEvaluator::pushOne(stack, new ExpOperation(tmp));      
+   } else {
+      ExpOperation *msg = static_cast<ExpOperation*>(args[0]);
+      tmp << " '" << msg->c_str() << "'";
+      ExpEvaluator::pushOne(stack, new ExpOperation(tmp));
+      message = std::string(msg->c_str());
+   }
+
+   // write to the POSIX queue
+   MQCommon::push((message + "\n").c_str());
+
+   // write to the log file
+   std::ofstream sar_log;
+   sar_log.open(SearchAndRescue::OUT_FILE, std::ios_base::app);
+   sar_log << message.c_str() << std::endl;
+   sar_log.close();
+}
+
+void SearchAndRescue::change_plmn(ObjList &stack, const ExpOperation &oper, GenObject *context) {
+   std::string mcc = "";
+   std::string mnc = "";
+   
+   ObjList args;
+   int argc = extractArgs(stack, oper, context, args);
+   String tmp;
+   tmp << "SearchAndRescue: change_plmn ";
+
+   for (int i = 0; i < argc; ++i) {
+      ExpOperation *op = static_cast<ExpOperation*>(args[i]);
+
+      switch (i) {
+      case 0:
+         mcc = std::string(op->c_str());
+         tmp << "MCC='" << *op << "' ";
+         break;
+      case 1:
+         mnc = std::string(op->c_str());
+         tmp << "MNC='" << *op << "' ";
+         break;
+      }
+   }
+
+   ExpEvaluator::pushOne(stack, new ExpOperation(tmp));
+
+   String chplmn;
+   chplmn << "chplmn.sh " << mcc.c_str() << " " << mnc.c_str() << " &";
+   system(chplmn.c_str());
+}
+
+// --- Handler ---
+
+SearchAndRescueHandler::SearchAndRescueHandler() : 
+      MessageHandler("script.init", 90, "searchandrescue") {}
+
+static const Regexp s_libs("\\(^\\|,\\)searchandrescue\\($\\|,\\)");
+static const Regexp s_objs("\\(^\\|,\\)SearchAndRescue\\($\\|,\\)");
+
+bool SearchAndRescueHandler::received(Message &msg) {
+
+   ScriptContext *ctx = YOBJECT(ScriptContext, msg.userData());
+   const String &lang = msg[YSTRING("language")];
+   Debug(DebugInfo, 
+      "SearchAndRescueHandler received script.init, language %s, context: %p", 
+      lang.c_str(), ctx);
+
+   if (!ctx || (lang && lang != YSTRING("javascript"))) 
+      return false;
+
+   bool ok = msg.getBoolValue(YSTRING("startup")) ||
+      s_libs.matches(msg.getValue(YSTRING("libraries"))) ||
+      s_objs.matches(msg.getValue(YSTRING("objects")));
+
+   if (ok) SearchAndRescue::initialize(ctx);
+   return ok;
+   
+}
+
+// --- Plugin ---
+
+SearchAndRescuePlugin::SearchAndRescuePlugin() :
+      Plugin("searchandrescue", true), m_handler(0) {
+   Output("Hello, I am module SearchAndRescuePlugin");
+}
+
+void SearchAndRescuePlugin::initialize() {
+   Output("Initializing SearchAndRescuePlugin");
+   if (!m_handler)
+      Engine::install((m_handler = new SearchAndRescueHandler));
+}
+
+INIT_PLUGIN(SearchAndRescuePlugin);
+
diff --git a/yate/tools/Makefile.in b/yate/tools/Makefile.in
new file mode 100644
index 0000000..3f96d72
--- /dev/null
+++ b/yate/tools/Makefile.in
@@ -0,0 +1,17 @@
+# Makefile
+# This file holds rules to install scripts and tools onto the system
+
+# override DESTDIR at install time to prefix the install directory
+
+SCRIPTS := chplmn.sh
+
+srcdir := @YATE_SCR@
+
+.PHONY: all
+all:
+
+install: all
+	@mkdir -p "/usr/local/bin/" && for i in $(SCRIPTS) ; do install -m 0755 @srcdir@/$$i /usr/local/bin/ ; done 
+
+uninstall:
+	for i in $(SCRIPTS) ; do \	rm -f /usr/local/bin/$$i ; done
diff --git a/yate/tools/chplmn.sh b/yate/tools/chplmn.sh
new file mode 100755
index 0000000..a11ebf2
--- /dev/null
+++ b/yate/tools/chplmn.sh
@@ -0,0 +1,28 @@
+#!/usr/bin/env bash
+
+# chplmn.sh: a script to automate a TCP connection to the yate rmanager 
+# and chagne the BTS's PLMN
+# 
+# Cellular Search and Rescue - Cellular Sensor BTS
+#   Copyright (C) 2017 Microsoft
+# 
+# This file is part of cell-sar/the Yate-BTS Project http://www.yatebts.com
+# 
+# cell-sar is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 2 of the License, or
+# (at your option) any later version.
+# 
+# cell-sar is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with cell-sar.  If not, see <http://www.gnu.org/licenses/>.
+
+nc -z localhost 5038
+if [ $? -eq 0 ]; then
+   printf "mbts cellid $1 $2\nmbts reloadPLMN\n" | nc -q 5 localhost 5038 > /dev/null
+fi
+
